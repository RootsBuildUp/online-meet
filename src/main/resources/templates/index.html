<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <title>Multi-User Video Room</title>
    <style>
        video {
            width: 320px;
            height: 240px;
            margin: 8px;
            background: black;
        }

        #videos {
            display: flex;
            flex-wrap: wrap;
        }
    </style>
</head>
<body>
<h1>Multi-User Video Room</h1>

<label>Room ID: <input id="roomId" value=""></label>
<label>User ID: <input id="clientId" value=""></label>
<label>User Name: <input id="displayName" value=""></label>
<button onclick="joinRoom()">Join Room</button>

<div id="videos"></div>

<script>
    const videos = document.getElementById('videos');
    let ws;
    let localStream;
    let localPc;
    const peers = {}; // clientId -> RTCPeerConnection
    let roomId;
    let displayName;
    let clientId;

    async function joinRoom() {
        console.log(peers)
        roomId = document.getElementById('roomId').value.trim();
        clientId = document.getElementById('clientId').value.trim();
        displayName = document.getElementById('displayName').value.trim();

        if (!roomId || !clientId || !displayName) {
            alert('Please enter Room ID, User ID, and Display Name');
            return;
        }

        try {
            // Check media devices
            const devices = await navigator.mediaDevices.enumerateDevices();
            const hasVideo = devices.some(d => d.kind === 'videoinput');
            const hasAudio = devices.some(d => d.kind === 'audioinput');

            if (!hasVideo && !hasAudio) {
                alert("No camera or microphone found on this device.");
                return;
            }

            // Get local media
            localStream = await navigator.mediaDevices.getUserMedia({video: hasVideo, audio: hasAudio});
            addVideo(localStream, clientId, true);

            // Connect WebSocket
            const wsUrl = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws';
            ws = new WebSocket(wsUrl);
            console.log(ws)

            ws.onopen = () => {
                console.log('WebSocket connected');
                ws.send(JSON.stringify({
                    type: 'join',
                    roomId,
                    clientId,
                    displayName,
                }));
            };

            ws.onmessage = async (event) => {
                console.log(event)
                const msg = JSON.parse(event.data);
                console.log('ws received : ', msg)

                switch (msg.type) {
                    case 'offer':
                        if (msg.clientId === clientId) break;

                        console.log('Received offer from', msg.clientId);

                        let pc = createPeerConnection(msg.clientId);
                        peers[msg.clientId] = pc;

                        await pc.setRemoteDescription({type: 'offer', sdp: msg.sdp});
                        let answer = await pc.createAnswer();
                        await pc.setLocalDescription(answer);

                        ws.send(JSON.stringify({
                            type: 'answer',
                            roomId,
                            clientId,
                            displayName,
                            sdp: answer.sdp
                        }));
                        break;

                    case 'answer':
                        if (msg.clientId === clientId) break;

                        console.log('Received ' + msg.type + ' from', msg.clientId);

                        let pcA = createPeerConnection(msg.clientId);
                        peers[msg.clientId] = pcA;

                        await pcA.setRemoteDescription({type: 'offer', sdp: msg.sdp});
                        break;

                    case 'answer-old':
                        if (!peers[msg.clientId]) break;

                        console.log('Received answer from', msg.clientId);
                        await peers[msg.clientId].setRemoteDescription({type: 'answer', sdp: msg.sdp});
                        break;

                    case 'ice':
                        if (!peers[msg.clientId]) break;

                        console.log('Received ICE from', msg.clientId);
                        try {
                            await peers[msg.clientId].addIceCandidate(new RTCIceCandidate(msg.candidate));
                        } catch (e) {
                            console.warn('Error adding ICE candidate:', e);
                        }
                        break;

                    case 'new-publisher':
                        console.log('New publisher joined:', msg.clientId);
                        await createOfferForPeer(msg);
                        break;
                }
            };

            ws.onclose = () => console.log('WebSocket closed');

            // Create local publisher peer
            localPc = new RTCPeerConnection();
            localStream.getTracks().forEach(track => localPc.addTrack(track, localStream));

            localPc.onicecandidate = e => {
                if (e.candidate) {
                    ws.send(JSON.stringify({
                        type: 'ice',
                        roomId,
                        clientId,
                        displayName,
                        candidate: e.candidate
                    }));
                }
            };

        } catch (err) {
            console.error('Error accessing media devices:', err);
            alert("Could not access camera/microphone. Please check permissions.");
        }
    }

    // Create a peer connection for remote user
    function createPeerConnection(remoteId) {
        const pc = new RTCPeerConnection(
            {
                iceServers: [
                    {urls: 'stun:stun.l.google.com:19302'} // Free public STUN server
                ]
            }
        );

        pc.ontrack = event => addVideo(event.streams[0], remoteId, false);

        pc.onicecandidate = e => {
            if (e.candidate) {
                ws.send(JSON.stringify({
                    type: 'ice',
                    roomId,
                    clientId,
                    displayName,
                    candidate: e.candidate
                }));
            }
        };

        return pc;
    }

    // Initiate offer to new peer
    async function createOfferForPeer(msg) {
        const pc = createPeerConnection(msg.clientId);
        peers[msg.clientId] = pc;
        console.log(pc)

        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);

        ws.send(JSON.stringify({
            type: 'offer',
            roomId,
            clientId: msg.clientId,
            displayName: msg.displayName,
            sdp: offer.sdp
        }));
    }

    // Add video element
    function addVideo(stream, id, mute) {
        let v = document.getElementById(id);

        if (!v) {
            v = document.createElement("video");
            v.id = id;
            v.autoplay = true;
            v.setAttribute("playsinline", "true"); // Important for mobile Safari
            if (mute) {
                v.setAttribute("muted", "true"); // Important for mobile Safari
                v.muted = mute;
            }               // Must be set BEFORE srcObject
            v.playsInline = true;             // Also add the JS property (for completeness)
            videos.appendChild(v);
        }

        v.srcObject = stream;
        // Try to play explicitly (some browsers require a play call)
        v.play().catch(err => console.warn("Video play failed:", err));
        console.log(stream)

        console.log(v);
    }
</script>
</body>
</html>
